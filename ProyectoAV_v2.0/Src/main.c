
/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2024 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include<stdbool.h>
#include "stm32l4xx.h"
#include <GPIOx.h>
#include <I2Cx.h>
#include <CANx.h>
#include <SSD1306.h>
#include <MPU6050.h>
#include <NVIC.h>





//Simplified Definitions
#define GPIO_MODER_INPUT				(0U)
#define GPIO_MODER_OUTPUT				(1U)
#define GPIO_OTYPER_PP                   0UL //Push pull
#define GPIO_OTYPER_OD                   1UL //Open Drain
#define GPIO_OSPEEDR_0                   0UL //
#define GPIO_MODER_MODE_AF               2UL //Alternate Function
#define GPIO_OSPEEDR_HS                  3UL //High Speed

#define MSI_16MHz  0x80

/*********DECLARACION DE LAS FUNCIONES DEL MAIN PRINCIPAL************/

void MPU6050_Read_Ace_Giro(void);
void ActualizarPantalla(float N1, float N2);
void SecuanciaInicio(void);
void Init_Peripheral(void);
void Conf_Peripheral(void);
void delay(uint32_t n);
/*********FIN DE LAS FUNCIONES DEL MAIN PRINCIPAL************/



/*********DECLARACION DE VARIABLES GLOBALES ************/

/*****Variables para guardar la Aceleracion Lineal de X, Y, Z, directamente del MPU***************/
int16_t AC_X=0;
int16_t AC_Y=0;
int16_t AC_Z=0;

float AX=0;
float AY=0;
float AZ=0;


/*****Variables para guardar la Aceleracion Angular de X, Y, Z, directamente del MPU***************/
int16_t G_X=0;
int16_t G_Y=0;
int16_t G_Z=0;

float GX=0;
float GY=0;
float GZ=0;

int AB, FB, GB, W;

/*********FIN DE VARIABLES GLOBALES ************/
CAN_FIFOMailBox_TypeDef *FIFOmailBox0,*FIFOmailBox1;


int main(void)
{
	Init_Peripheral();
	Conf_Peripheral();
    //SSD1306_Init(); //Funcion para configurar la pantalla
    //SSD1306_Clear(); //Funcion para limpiar la pantalla
    MPU6050_Init(); //INICIALIZAR Y CONFIGURAR REGISTROSD EL MPU6050
    //SecuanciaInicio(); //Secuencia de la interfaz de usuario - inicio
    //I2C_Tx_2Bytes(I2C3, AdreSSD1306, ControlbC, SSD1306_SETPAGE0);
	//CONFIGURAR FILTROS

	NVIC_Enable(CAN1_RX0_IRQn, 4);
	NVIC_Enable(CAN1_RX1_IRQn, 5);
	CANx_EnFIFO0Ints(CAN1);
	CANx_EnFIFO1Ints(CAN1);
    CAN_FilterInit (CAN1, List_mode, Single_32bit, Fifo_0, 0x00); //CAN1, Mode , Scale, FIFO, Localidad
    CAN_SetFilterValue(CAN1, 0x7E8, 0x7E8, 0x00);  //CAN1, ID , MSK, Localidad

    //CONFIGURAR MAILBOXS
    CAN_MailboxConfig(CAN1, false, 0x7DF, false, 0x0); //CAN1, ExtededID, IDE, RTR, Localidad
    CAN_SendData(CAN1, 8, 0x00000000000D0102, 0x0); //CAN1, DLC , DATA, Localidad

    //CONFIGURAR MAILBOXS
    CAN_MailboxConfig(CAN1, false, 0x7DF, false, 0x1); //CAN1, ExtededID, IDE, RTR, Localidad
    CAN_SendData(CAN1, 8, 0x00000000002F0102, 0x1); //CAN1, DLC , DATA, Localidad
   // CAN_RequestTransmission(CAN1, 0x00);


    while (!(GPIOC->IDR & GPIO_IDR_IDR_2)) {
        //CAN_RequestTransmission(CAN1, 0x00);
        GPIOC->ODR ^= GPIO_ODR_ODR_13;
	    delay(300000);

        // Se queda en este bucle mientras el botón está en 0 (no presionado)
    }

	 while (1){

		if (GPIOC->IDR & GPIO_IDR_IDR_2){
	    		    CLEAR_BIT(GPIOC->ODR, GPIO_ODR_ODR_13);
	    	     //   CAN_RequestTransmission(CAN1, 0x01);
	    			delay(200000);
		 }
	 else {
		 GPIOC->ODR ^= GPIO_ODR_ODR_13;
		 MPU6050_Read_Ace_Giro();
	 }
		delay(150000);

/*

		 //Lectura de la Aceleracion en AX y AY


		 //Logica para determinar aceleraciones y frenados bruscos
		 MPU6050_Read_Ace_Giro();

		  if (AX > 0.2){
			  I2C_Tx_2Bytes(I2C3, AdreSSD1306, ControlbC, SSD1306_SETPAGE0);
			  SSD1306_PosCom(43);
			  Flecha_Arriba();
			  I2C_Tx_2Bytes(I2C3, AdreSSD1306, ControlbC, SSD1306_SETPAGE5);
			  SSD1306_PosCom(0);
			  SSD1306_WriteString("                                ");
			  I2C_Tx_2Bytes(I2C3, AdreSSD1306, ControlbC, SSD1306_SETPAGE5);
			  SSD1306_PosCom(0);
			  SSD1306_WriteString("! ACELERACIÓN !");
			  AB = AB + 1;
			 // I2C_delay(300000);
		  }else if(AX < -0.2){
			  I2C_Tx_2Bytes(I2C3, AdreSSD1306, ControlbC, SSD1306_SETPAGE3);
			  SSD1306_PosCom(43);
			  Flecha_Abajo();
			  I2C_Tx_2Bytes(I2C3, AdreSSD1306, ControlbC, SSD1306_SETPAGE5);
			  SSD1306_PosCom(0);
			  SSD1306_WriteString("                                ");
			  I2C_Tx_2Bytes(I2C3, AdreSSD1306, ControlbC, SSD1306_SETPAGE5);
			  SSD1306_PosCom(0);
			  SSD1306_WriteString("! FRENADO !");
			  FB= FB + 1;
			  //I2C_delay(300000);
		  } else {
			  I2C_Tx_2Bytes(I2C3, AdreSSD1306, ControlbC, SSD1306_SETPAGE3);
		      SSD1306_PosCom(43);
		      Vacear();
	   		  I2C_Tx_2Bytes(I2C3, AdreSSD1306, ControlbC, SSD1306_SETPAGE0);
	   		  SSD1306_PosCom(43);
	   		  Vacear();
			  I2C_Tx_2Bytes(I2C3, AdreSSD1306, ControlbC, SSD1306_SETPAGE5);
			  SSD1306_PosCom(0);
			  SSD1306_WriteString(" ! PROYECTO AV SS !");
			  I2C_delay(4000);
		  }

		  if (GZ > 200.9){
			  I2C_Tx_2Bytes(I2C3, AdreSSD1306, ControlbC, SSD1306_SETPAGE5);
			  SSD1306_PosCom(0);
			  SSD1306_WriteString("                                ");
			  I2C_Tx_2Bytes(I2C3, AdreSSD1306, ControlbC, SSD1306_SETPAGE5);
			  SSD1306_PosCom(0);
			  SSD1306_WriteString("! GIRO BRUSCO !");
			  GB = GB + 1;
			 // I2C_delay(300000);
		  }

		  if (AZ < 0.4){
			  I2C_Tx_2Bytes(I2C3, AdreSSD1306, ControlbC, SSD1306_SETPAGE5);
			  SSD1306_PosCom(0);
			  SSD1306_WriteString("                                ");
			  I2C_Tx_2Bytes(I2C3, AdreSSD1306, ControlbC, SSD1306_SETPAGE5);
			  SSD1306_PosCom(0);
			  SSD1306_WriteString("! WARNING !");
			  W = W + 1;
			 // I2C_delay(300000);
		  }





		    char buffer[64]; // Buffer suficientemente grande para la cadena completa
		    // Convertir los valores enteros a cadenas de caracteres y concatenarlos
		    sprintf(buffer, "A: %d F: %d G: %d W: %d ", AB, FB, GB, W);
		    // Imprimir la cadena resultante en la pantalla SSD1306
			  I2C_Tx_2Bytes(I2C3, AdreSSD1306, ControlbC, SSD1306_SETPAGE7);
			  SSD1306_PosCom(0);
		    SSD1306_WriteString(buffer);

*/


		  //Logica para sistema de orientaicon

/*
	    	// Commute bit 13 with a xor operation
			GPIOC->ODR ^= 0x00002000;
			//delay(30000);
		  I2C_Tx_2Bytes(I2C3, AdreSSD1306, ControlbC, SSD1306_SETPAGE1);
		  SSD1306_PosCom(0);
		  if (AY > 0.2){
			  Flecha_Izquierda();
		  } else if(AY < -0.2){
			  Flecha_Derecha();
		  }else{
			  I2C_Tx_2Bytes(I2C3, AdreSSD1306, ControlbC, SSD1306_SETPAGE1);
			  SSD1306_PosCom(0);
			  Vacear();
			  I2C_Tx_2Bytes(I2C3, AdreSSD1306, ControlbC, SSD1306_SETPAGE2);
			  SSD1306_PosCom(0);
			  Vacear();
			  I2C_Tx_2Bytes(I2C3, AdreSSD1306, ControlbC, SSD1306_SETPAGE1);
			  SSD1306_PosCom(90);
			  Vacear();
			  I2C_Tx_2Bytes(I2C3, AdreSSD1306, ControlbC, SSD1306_SETPAGE2);
			  SSD1306_PosCom(90);
			  Vacear();
		  }

		  if (AX > 0.2){
			  I2C_Tx_2Bytes(I2C3, AdreSSD1306, ControlbC, SSD1306_SETPAGE0);
			  SSD1306_PosCom(43);
			  Flecha_Arriba();
		  }else if(AX < -0.2){
			  I2C_Tx_2Bytes(I2C3, AdreSSD1306, ControlbC, SSD1306_SETPAGE3);
			  SSD1306_PosCom(43);
			  Flecha_Abajo();
		  } else {
			  I2C_Tx_2Bytes(I2C3, AdreSSD1306, ControlbC, SSD1306_SETPAGE3);
		      SSD1306_PosCom(43);
		      Vacear();
	   		  I2C_Tx_2Bytes(I2C3, AdreSSD1306, ControlbC, SSD1306_SETPAGE0);
	   		  SSD1306_PosCom(43);
	   		  Vacear();
		  }
		  //Fin Logica Sistema de orientacion
		  I2C_delay(30);*/
   }

 }




void Init_Peripheral(void){
	  /*CONFIGURACIÓN DEL RELOJ*/
	  SystCLK_SetMSI(MSI_16MHz); //Configura 16MHz como  reloj
	  RCC_EnPort(GPIOB);//configura reloj en puerto B Para CANX
	  //RCC_EnPort(GPIOD);//configura reloj en puerto D PUERTO PARA SALIDA DIGITAL - CONMUTA UN TRANSISTOR PARA ALIMENTAR UN LED
	  RCC_EnPort(GPIOC);//configura reloj en puerto C para I2C

	  RCC_En_I2C(I2C3); // Habilitar reloj al periférico I2C.
	  RCC_En_CANx(CAN1);// Habilitar reloj al periferico CAN
}

void Conf_Peripheral(void){
	  GPIOx_InitIO(GPIOC, 2, GPIO_MODER_INPUT, false);
	  //GPIOx_InitIO(GPIOB, 8, GPIO_MODER_OUTPUT, false);
	  GPIOx_InitAF(GPIOC, 0, 1, 2, 4, false); /*Puerto C / PIN 0 / Configura Open Drain / High speed /  Función alterna 4 - I2C3_SCL / Habilita Resistencia de Pull -Up  */
	  GPIOx_InitAF(GPIOC, 1, 1, 2, 4, false); /*Puerto C / PIN 1 / Configura Open Drain / High speed /  Función alterna 4 - I2C3_SDA / Habilita Resistencia de Pull -Up  */
	  //inicializa funcion alterna para CAN1 RX en pin B8
	  GPIOx_InitAF(GPIOB, 8, GPIO_OTYPER_PP, GPIO_OSPEEDR_HS, 9 , false); /*Puerto B / PIN 0 / Configura Push Pull / High speed /  Función alterna 9 - CAN1_RX / Habilita Resistencia de Pull -Up  */
	  //inicializa funcion alterna para CAN1 TX en pin B9
	  GPIOx_InitIO(GPIOC, 13, GPIO_MODER_OUTPUT, false);
	  GPIOx_InitAF(GPIOB, 9, GPIO_OTYPER_PP, GPIO_OSPEEDR_HS, 9 , false); /*Puerto B / PIN 0 / Configura Push Pull / High speed /  Función alterna 9 - CAN1_TX / Habilita Resistencia de Pull -Up  */
	  I2C_Init(I2C3);
	  CANx_Init(CAN1);
	  CANx_BitTiming_500Kz(CAN1);
	  CLEAR_BIT(CAN1->MCR, CAN_MCR_INRQ);//limpia bandera de modo inicialización
	 // CAN_RequestTransmission(CAN1, 0x00);
  //  while(CAN1->MSR & CAN_MSR_INAK) {}; //Esperamos a que el bit CAN_MSR_INAK se limpie ****ENTRA
}

void MPU6050_Read_Ace_Giro(void){
	  AC_X =  MPU6050_Read(MPU6050_ACCEL_XOUT_H);
	  AX=(AC_X/16384.0);
	  AC_Y =  MPU6050_Read(MPU6050_ACCEL_YOUT_H);
	  AY=(AC_Y/16384.0);
	  AC_Z =  MPU6050_Read(MPU6050_ACCEL_ZOUT_H);
	  AZ=(AC_Z/16384.0);
	  G_X =  MPU6050_Read(MPU6050_GYRO_XOUT_H);
	  GX=(G_X/131.0);
	  G_Y =  MPU6050_Read(MPU6050_GYRO_YOUT_H);
	  GY=(G_Y/131.0);
	  G_Z = MPU6050_Read(MPU6050_GYRO_ZOUT_H);
	  GZ=(G_Z/131.0);
}


void SecuanciaInicio(void){
	  I2C_Tx_2Bytes(I2C3, AdreSSD1306, ControlbC, 0X2E); //Escrollin off
	  I2C_Tx_2Bytes(I2C3, AdreSSD1306, ControlbC, 0xA5);
	  I2C_delay(100000);
	  GPIOC->ODR ^= 0x00002000;
	  I2C_Tx_2Bytes(I2C3, AdreSSD1306, ControlbC, 0xA4);
	  I2C_delay(100000);
	  GPIOC->ODR ^= 0x00002000;
	  I2C_Tx_2Bytes(I2C3, AdreSSD1306, ControlbC, 0xA5);
	  I2C_delay(100000);
	  GPIOC->ODR ^= 0x00002000;
	  I2C_Tx_2Bytes(I2C3, AdreSSD1306, ControlbC, 0xA4);
	  I2C_delay(100000);
	  GPIOC->ODR ^= 0x00002000;
	  I2C_Tx_2Bytes(I2C3, AdreSSD1306, ControlbC, 0xA5);
	  I2C_delay(100000);
	  GPIOC->ODR ^= 0x00002000;
	  I2C_Tx_2Bytes(I2C3, AdreSSD1306, ControlbC, 0xA4);
	  I2C_delay(100000);
	  GPIOC->ODR ^= 0x00002000;
	  I2C_Tx_2Bytes(I2C3, AdreSSD1306, ControlbC, SSD1306_SETPAGE0);
	  SSD1306_PosCom(0);
	  SSD1306_WriteString("  ! LIESE LAB 2024 ! ");
	  I2C_Tx_2Bytes(I2C3, AdreSSD1306, ControlbC, SSD1306_SETPAGE3);
	  SSD1306_PosCom(0);
	  SSD1306_WriteString("    JOSHUA ROSAS");
	  I2C_delay(450000);
	  I2C_Tx_2Bytes(I2C3, AdreSSD1306, ControlbC, SSD1306_SETPAGE3);
	  SSD1306_PosCom(0);
	  SSD1306_WriteString("                                ");
	  I2C_Tx_2Bytes(I2C3, AdreSSD1306, ControlbC, SSD1306_SETPAGE3);
	  SSD1306_PosCom(0);
	  SSD1306_WriteString("! POSITION SYSTEM !");
	  I2C_delay(450000);
	  I2C_Tx_2Bytes(I2C3, AdreSSD1306, ControlbC, SSD1306_SETPAGE3);
	  SSD1306_PosCom(0);
	  SSD1306_WriteString("                                ");
	  I2C_Tx_2Bytes(I2C3, AdreSSD1306, ControlbC, SSD1306_SETPAGE3);
	  SSD1306_PosCom(0);
	  SSD1306_WriteString("   ! START !   ");
	  I2C_delay(450000);
	  SSD1306_Clear();
}


void delay(uint32_t n)
{
	while(n--);
}


void CAN1_RX0_IRQHandler(){
	NVIC_ClearPendingIRQ(CAN1_RX0_IRQn);
	CAN1_Rx0_FIFOx (CAN1, FIFOmailBox0);

}
void CAN1_RX1_IRQHandler(){
     NVIC_ClearPendingIRQ(CAN1_RX1_IRQn);
     CAN1_Rx1_FIFOx (CAN1, FIFOmailBox1);
}









